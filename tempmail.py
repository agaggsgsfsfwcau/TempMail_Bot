import re
import time
import random
import string
import hashlib
import requests
from bs4 import BeautifulSoup
from pyrogram.enums import ParseMode, ChatType
from pyrogram import Client, filters

from pyrogram.types import (
    InlineKeyboardMarkup,
    InlineKeyboardButton
)

from config import (
    API_ID,
    API_HASH,
    BOT_TOKEN
)

# Initialize the bot client
# "bot_session" is the name for the Pyrogram session file.
# api_id, api_hash, and bot_token are obtained from Telegram.
# workers: Number of concurrent tasks Pyrogram can handle.
# parse_mode: Ensures Markdown formatting in messages.
bot = Client(
    "bot_session",
    api_id=API_ID,
    api_hash=API_HASH,
    bot_token=BOT_TOKEN,
    workers=1000,  # Increased workers for better concurrency
    parse_mode=ParseMode.MARKDOWN
)

# In-memory storage for user data and tokens.
# IMPORTANT: For persistence across bot restarts, consider using a database (e.g., SQLite, PostgreSQL, or a simple JSON file).
# These dictionaries will be cleared if the bot process stops.
user_data = {}  # Currently not used, but can be extended for user-specific settings.
token_map = {}  # Maps a short, unique ID (generated by the bot) to the Mail.tm token.
                # This is used for the "Check Emails" inline button after email generation.
user_tokens = {} # Maps Telegram user_id to their current Mail.tm token.
                 # This is used to retrieve the correct token when a user clicks a "read message" button.

MAX_MESSAGE_LENGTH = 4000  # Telegram's maximum message length. Messages longer than this will be truncated.

BASE_URL = "https://api.mail.tm" # Base URL for the Mail.tm API.
HEADERS = {
    "Content-Type": "application/json", # Specifies that the request body is JSON.
    "Accept": "application/json"        # Specifies that the client expects a JSON response.
}

def short_id_generator(email):
    """
    Generates a short, unique ID for an email.
    This ID is used in callback data for inline buttons to reference a specific email's token.
    It's based on an MD5 hash of the email and current timestamp to ensure uniqueness.
    """
    unique_string = email + str(time.time())
    return hashlib.md5(unique_string.encode()).hexdigest()[:10]

def generate_random_username(length=8):
    """
    Generates a random lowercase username of a specified length.
    Used for creating random temporary email addresses.
    """
    return ''.join(random.choice(string.ascii_lowercase) for i in range(length))

def generate_random_password(length=12):
    """
    Generates a random password using a mix of letters and digits.
    Used for creating temporary email accounts.
    """
    characters = string.ascii_letters + string.digits
    return ''.join(random.choice(characters) for i in range(length))

def get_domain():
    """
    Fetches an available domain from the Mail.tm API.
    It tries to get the first domain from the list provided by the API.
    Includes error handling for network requests.
    """
    try:
        response = requests.get(f"{BASE_URL}/domains", headers=HEADERS)
        response.raise_for_status()  # Raise an exception for HTTP errors (4xx or 5xx)
        data = response.json()
        if isinstance(data, list) and data:
            return data[0]['domain']
        elif 'hydra:member' in data and data['hydra:member']:
            return data['hydra:member'][0]['domain']
        return None
    except requests.exceptions.RequestException as e:
        print(f"Error fetching domain: {e}")
        return None

def create_account(email, password):
    """
    Creates a new temporary email account on Mail.tm with the given email address and password.
    Includes error handling for network requests and API responses.
    """
    data = {
        "address": email,
        "password": password
    }
    try:
        response = requests.post(f"{BASE_URL}/accounts", headers=HEADERS, json=data)
        response.raise_for_status()  # Raise an exception for HTTP errors
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error creating account: {e}")
        # Print the response text for debugging if an error occurs
        print(f"Response: {response.text if 'response' in locals() else 'No response received'}")
        return None

def get_token(email, password):
    """
    Authenticates with Mail.tm using the email and password to retrieve an access token.
    This token is required for subsequent API calls to list or read messages.
    Includes error handling for network requests and API responses.
    """
    data = {
        "address": email,
        "password": password
    }
    try:
        response = requests.post(f"{BASE_URL}/token", headers=HEADERS, json=data)
        response.raise_for_status()  # Raise an exception for HTTP errors
        return response.json().get('token')
    except requests.exceptions.RequestException as e:
        print(f"Error retrieving token: {e}")
        # Print the response text for debugging if an error occurs
        print(f"Token Response: {response.text if 'response' in locals() else 'No response received'}")
        return None

def get_text_from_html(html_content_list):
    """
    Converts a list of HTML content (e.g., from an email body) into clean plain text.
    It specifically handles <a> tags by replacing them with their text and the URL in brackets,
    making links readable in plain text Telegram messages.
    """
    html_content = ''.join(html_content_list)
    soup = BeautifulSoup(html_content, 'html.parser')

    # Iterate through all <a> tags found in the HTML.
    for a_tag in soup.find_all('a', href=True):
        url = a_tag['href']
        # Create new content string including the link text and its URL.
        new_content = f"{a_tag.text} [{url}]"
        # Replace the original <a> tag's content with the new_content.
        a_tag.string = new_content

    # Get all text content from the modified BeautifulSoup object.
    text_content = soup.get_text()
    # Clean up multiple spaces and newlines, then strip leading/trailing whitespace.
    cleaned_content = re.sub(r'\s+', ' ', text_content).strip()
    return cleaned_content

def list_messages(token):
    """
    Lists recent messages for an account using the provided Mail.tm access token.
    Includes error handling for network requests and API responses.
    """
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "Authorization": f"Bearer {token}" # Authorization header with the bearer token.
    }
    try:
        response = requests.get(f"{BASE_URL}/messages", headers=headers)
        response.raise_for_status()  # Raise an exception for HTTP errors
        data = response.json()
        # Mail.tm API can return messages as a direct list or within 'hydra:member'.
        if isinstance(data, list):
            return data
        elif 'hydra:member' in data:
            return data['hydra:member']
        else:
            return []
    except requests.exceptions.RequestException as e:
        print(f"Error listing messages: {e}")
        return []

@bot.on_message(filters.command('start'))
async def start(client, message):
    """
    Handles the /start command.
    Sends a welcome message to the user with instructions on how to use the bot's commands.
    """
    welcome_message = (
        "Welcome to our Temp Mail Bot! üéâ\n\n"
        "You can use the following commands to manage temporary email addresses:\n\n"
        "‚û¢ `/tmail` - Generate a random mail with a password.\n"
        "‚û¢ `/tmail [username]:[pass]` - Generate a specific mail with a password.\n"
        "‚û¢ `/cmail [mail token]` - Check the 10 most recent mails using your mail token.\n\n"
        "‚ú® Note: When you generate a mail and password, you will receive a mail token. "
        "This token allows you to check the 10 most recent emails received by your temporary mail address. "
        "Each email has a different token, so please keep your tokens private and secure. üõ°Ô∏è"
    )
    await message.reply(welcome_message)

@bot.on_message(filters.command('tmail'))
async def generate_mail(client, message):
    """
    Handles the /tmail command.
    Generates a temporary email address, creates an account on Mail.tm,
    retrieves a token, and provides the details to the user.
    Supports both random and user-defined usernames/passwords.
    """
    # Ensure the command is used in a private chat for security and functionality.
    if message.chat.type != ChatType.PRIVATE:
        await message.reply("Please use this bot in private chat only.")
        return

    # Send a loading message to indicate processing.
    loading_msg = await message.reply("**Generating your temporary email...**")

    # Parse arguments from the message.
    # If no arguments, args_text will be empty.
    args_text = message.text.split(maxsplit=1)[1] if len(message.text.split()) > 1 else ""
    args = args_text.split()
    
    username = None
    password = None

    # Check if the user provided a custom username and password.
    if len(args) == 1 and ':' in args[0]:
        parts = args[0].split(':', 1) # Split only on the first colon to allow passwords with colons.
        if len(parts) == 2:
            username = parts[0]
            password = parts[1]
        else:
            # Inform the user about incorrect format.
            await message.reply("**Invalid format.** Please use `/tmail [username]:[password]` or just `/tmail`.")
            await bot.delete_messages(message.chat.id, [loading_msg.id])
            return
    else:
        # Generate random username and password if no custom ones are provided.
        username = generate_random_username()
        password = generate_random_password()

    # Get an available domain from Mail.tm.
    domain = get_domain()
    if not domain:
        await message.reply("**Failed to retrieve a domain. Please try again later.**")
        await bot.delete_messages(message.chat.id, [loading_msg.id])
        return

    email = f"{username}@{domain}"
    
    # Create the account on Mail.tm.
    account = create_account(email, password)
    if not account:
        await message.reply("**Failed to create account. Username might be taken or a server error occurred. Please try a different username or try again later.**")
        await bot.delete_messages(message.chat.id, [loading_msg.id])
        return

    # A small delay to ensure the account is fully registered on Mail.tm's side
    # before attempting to retrieve a token. This can prevent "account not found" errors.
    time.sleep(2)

    # Get the access token for the newly created account.
    token = get_token(email, password)
    if not token:
        await message.reply("**Failed to retrieve token for the new account. Please try again.**")
        await bot.delete_messages(message.chat.id, [loading_msg.id])
        return

    # Generate a short ID for this email to be used in callback data.
    short_id = short_id_generator(email)
    token_map[short_id] = token # Store the token mapped to the short ID.
    
    # Store the token for the current user. This is crucial for the `read_message` callback
    # which uses `user_tokens` to find the correct token.
    user_tokens[message.from_user.id] = token

    # Construct the output message with email details.
    output_message = (
        "**üìß Smart-Email Details üìß**\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"**üìß Email:** `{email}`\n"
        f"**üîë Password:** `{password}`\n"
        f"**üîí Token:** `{token}`\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "**Note: Keep the token to Access Mail. It will be lost if the bot restarts.**"
    )

    # Create an inline keyboard button to check emails directly.
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton("Check Emails", callback_data=f"check_{short_id}")]
    ])

    # Reply with the email details and the inline keyboard.
    await message.reply(output_message, reply_markup=keyboard)
    # Delete the loading message.
    await bot.delete_messages(message.chat.id, [loading_msg.id])

@bot.on_callback_query(filters.regex(r'^check_'))
async def check_mail(client, callback_query):
    """
    Handles callback queries triggered by the "Check Emails" button.
    Lists the 10 most recent messages for the associated email.
    """
    # Extract the short ID from the callback data.
    short_id = callback_query.data.split('_')[1]
    # Retrieve the token using the short ID.
    token = token_map.get(short_id)

    if not token:
        # If token is not found (e.g., bot restarted, session expired), inform the user.
        await callback_query.answer("Session expired or token not found. Please generate a new email or use /cmail with your token.", show_alert=True)
        return

    # Update the user's current token in `user_tokens`. This is important because
    # the `read_message` function relies on `user_tokens` to find the token.
    user_tokens[callback_query.from_user.id] = token

    # Send a loading message.
    loading_msg = await callback_query.message.reply("**‚è≥ Checking Mails.. Please wait.**")

    # List messages using the retrieved token.
    messages = list_messages(token)
    if not messages:
        # If no messages are found, inform the user.
        await callback_query.answer("No messages received yet ‚ùå", show_alert=True)
        await bot.delete_messages(callback_query.message.chat.id, [loading_msg.id])
        return

    # Construct the output message for the list of emails.
    output = "**üìß Your Smart-Mail Messages üìß**\n"
    output += "**‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ**\n"
    
    buttons = []
    # Iterate through the 10 most recent messages and create buttons for each.
    for idx, msg in enumerate(messages[:10], 1):
        output += f"{idx}. From: `{msg['from']['address']}` - Subject: `{msg['subject']}`\n"
        button = InlineKeyboardButton(f"{idx}", callback_data=f"read_{msg['id']}")
        buttons.append(button)
    
    keyboard = []
    # Arrange the message buttons in rows of 5 for better presentation.
    for i in range(0, len(buttons), 5):
        keyboard.append(buttons[i:i+5])

    # Reply with the list of messages and the inline keyboard to read individual messages.
    await callback_query.message.reply(output, reply_markup=InlineKeyboardMarkup(keyboard))
    # Delete the loading message.
    await bot.delete_messages(callback_query.message.chat.id, [loading_msg.id])

@bot.on_callback_query(filters.regex(r"^close_message"))
async def close_message(client, callback_query):
    """
    Handles callback queries triggered by a "Close" button.
    Deletes the message to which the button is attached.
    """
    await callback_query.message.delete()

@bot.on_callback_query(filters.regex(r"^read_"))
async def read_message(client, callback_query):
    """
    Handles callback queries for reading a specific email message.
    The email content will be formatted as a quote using Telegram Markdown.
    """
    message_id = callback_query.data.split('_')[1]
    token = user_tokens.get(callback_query.from_user.id) # Get token from user-specific storage

    if not token:
        await callback_query.answer("**Token not found. Please use /cmail with your token again or generate a new email.**", show_alert=True)
        return

    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "Authorization": f"Bearer {token}"
    }
    
    try:
        response = requests.get(f"{BASE_URL}/messages/{message_id}", headers=headers)
        response.raise_for_status() # Raise an exception for HTTP errors
        details = response.json()

        message_text = "Content not available."
        if 'html' in details and details['html']:
            message_text = get_text_from_html(details['html'])
        elif 'text' in details and details['text']:
            message_text = details['text']
        
        # Format the message text as a quote by prefixing each line with '> '
        # This enhances readability by visually separating the email content.
        quoted_message_text = "\n".join([f"> {line}" for line in message_text.splitlines()])
        
        # Truncate the message if it's too long, considering the added quote prefixes.
        # We need to estimate the length increase due to '> ' per line.
        # A rough estimate: each line adds 2 characters ('> ').
        # For simplicity, we'll truncate the original text and then re-quote it if needed.
        # The buffer (200 chars) accounts for the quote prefixes and the "[message truncated]" suffix.
        if len(quoted_message_text) > MAX_MESSAGE_LENGTH:
            # Truncate the original message_text first to fit within a reasonable limit,
            # then re-quote it. This helps ensure the final quoted text fits.
            truncated_original_text = message_text[:MAX_MESSAGE_LENGTH - 200]
            quoted_message_text = "\n".join([f"> {line}" for line in truncated_original_text.splitlines()])
            quoted_message_text += "\n\n> ... [message truncated]" # Indicate truncation

        output = (
            f"**From:** `{details['from']['address']}`\n"
            f"**Subject:** `{details['subject']}`\n"
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"{quoted_message_text}" # Use the quoted message text here
        )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("Close", callback_data="close_message")]
        ])

        await callback_query.message.reply(output, disable_web_page_preview=True, reply_markup=keyboard)

    except requests.exceptions.RequestException as e:
        print(f"Error retrieving message details: {e}")
        await callback_query.message.reply("**Error retrieving message details. The message might have expired or the token is invalid.**")

@bot.on_message(filters.command('cmail'))
async def manual_check_mail(client, message):
    """Handles the /cmail command for manually checking emails with a provided token."""
    if message.chat.type != ChatType.PRIVATE:
        await message.reply("Please use this bot in private chat only.")
        return

    loading_msg = await message.reply("**‚è≥ Checking Mails.. Please wait.**")

    token = message.text.split(maxsplit=1)[1] if len(message.text.split()) > 1 else ""
    if not token:
        await message.reply("**Please provide a token after the /cmail command, e.g., `/cmail YOUR_TOKEN_HERE`**")
        await bot.delete_messages(message.chat.id, [loading_msg.id])
        return

    # Store the token for the current user for subsequent 'read' operations
    user_tokens[message.from_user.id] = token
    
    messages = list_messages(token)
    if not messages:
        await message.reply("**‚ùå No messages found or the token might be invalid. Please double-check your token.**")
        await bot.delete_messages(message.chat.id, [loading_msg.id])
        return

    output = "**üìß Your Temp Mail Messages üìß**\n"
    output += "**‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ**\n"
    
    buttons = []
    # Limit to the 10 most recent messages
    for idx, msg in enumerate(messages[:10], 1):
        output += f"{idx}. From: `{msg['from']['address']}` - Subject: `{msg['subject']}`\n"
        button = InlineKeyboardButton(f"{idx}", callback_data=f"read_{msg['id']}")
        buttons.append(button)

    keyboard = []
    # Arrange buttons in rows of 5
    for i in range(0, len(buttons), 5):
        keyboard.append(buttons[i:i+5])

    await message.reply(output, reply_markup=InlineKeyboardMarkup(keyboard))
    await bot.delete_messages(message.chat.id, [loading_msg.id])

# Run the bot
bot.run()
